import os
import json
import shutil
import pygame
import live2d.v2 as live2d
import errno

from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QLabel, QPushButton, QFileDialog,
    QMessageBox, QListWidget, QListWidgetItem, QHBoxLayout, QTableWidget,
    QHeaderView, QTableWidgetItem, QCheckBox, QLineEdit, QComboBox,
    QGroupBox, QFormLayout, QRadioButton
)
from PyQt5.QtCore import Qt

from sections.gen_jsonl import is_valid_live2d_json
from sections.py_live2d_editor import get_all_parts

PARTS_JSON_PATH = os.path.join("resource", "parts.json")


# ========= ÈÄöÁî®Â∑•ÂÖ∑ =========
def _ensure_dir(path: str):
    os.makedirs(path, exist_ok=True)

def _ensure_parent_dir(path: str):
    os.makedirs(os.path.dirname(path), exist_ok=True)

def _same_volume(src: str, dst: str) -> bool:
    """Windows: ÊØîËæÉÁõòÁ¨¶ÔºõPOSIX: ÊØîËæÉ st_dev„ÄÇ"""
    try:
        src_drive = os.path.splitdrive(os.path.abspath(src))[0].lower()
        dst_drive = os.path.splitdrive(os.path.abspath(dst))[0].lower()
        if src_drive or dst_drive:
            return src_drive == dst_drive
    except Exception:
        pass
    try:
        return os.stat(os.path.abspath(src)).st_dev == os.stat(os.path.abspath(os.path.dirname(dst))).st_dev
    except Exception:
        return False

def _fsync_file(path: str):
    try:
        with open(path, 'rb') as f:
            os.fsync(f.fileno())
    except Exception:
        pass

def _display_relpath(abs_path: str, base: str) -> str:
    """Áî®‰∫é UI ÊòæÁ§∫ÁöÑÁõ∏ÂØπË∑ØÂæÑÔºõË∑®ÁõòÂ§±Ë¥•ÂàôÈÄÄÂåñ‰∏∫Êñá‰ª∂Âêç"""
    try:
        rel = os.path.relpath(abs_path, base)
        return rel.replace("\\", "/")
    except ValueError:
        return os.path.basename(abs_path)

def _fsync_dir(dir_path: str):
    try:
        if os.name == "nt":
            return
        fd = os.open(dir_path, os.O_DIRECTORY)
        try:
            os.fsync(fd)
        finally:
            os.close(fd)
    except Exception:
        pass

def _dedup_target_path(dst_path: str) -> str:
    """Ëã•ÁõÆÊ†áÈáçÂêçÔºåËá™Âä®ËøΩÂä† _1/_2/..."""
    base = os.path.basename(dst_path)
    name, ext = os.path.splitext(base)
    folder = os.path.dirname(dst_path)
    final_dst = dst_path
    i = 1
    while os.path.exists(final_dst):
        final_dst = os.path.join(folder, f"{name}_{i}{ext}")
        i += 1
    return final_dst

def safe_move(src: str, dst: str) -> str:
    """
    ÂèØÈù†ÁßªÂä®Ôºö
      - ÂÖàÂ∞ùËØï shutil.move
      - Ë∑®ÁõòÊàñÂ§±Ë¥•Âàô copy2 + fsync + unlink
      - ËøîÂõûÊúÄÁªàÁõÆÊ†áÔºàÂê´ÈáçÂêçÂéªÈáçÔºâ
    """
    _ensure_parent_dir(dst)
    final_dst = _dedup_target_path(dst)

    try:
        shutil.move(src, final_dst)
        return final_dst
    except Exception as e:
        is_exdev = getattr(e, 'errno', None) == errno.EXDEV
        if is_exdev or not _same_volume(src, final_dst):
            try:
                shutil.copy2(src, final_dst)
                _fsync_file(final_dst)
                _fsync_dir(os.path.dirname(final_dst))
                os.unlink(src)
                _fsync_dir(os.path.dirname(src))
                return final_dst
            except Exception as e2:
                raise RuntimeError(f"Ë∑®ÁõòÂ§çÂà∂Âà†Èô§Â§±Ë¥•Ôºö{src} -> {final_dst}, ÈîôËØØ: {e2}") from e2
        else:
            try:
                shutil.copy2(src, final_dst)
                _fsync_file(final_dst)
                _fsync_dir(os.path.dirname(final_dst))
                os.unlink(src)
                _fsync_dir(os.path.dirname(src))
                return final_dst
            except Exception as e3:
                raise RuntimeError(f"Â§çÂà∂Âà†Èô§ÂÖúÂ∫ïÂ§±Ë¥•Ôºö{src} -> {final_dst}, ÈîôËØØ: {e3}") from e3


# ========= ‰∏ªÈ°µÈù¢ =========
class OpacityPresetPage(QWidget):
    def __init__(self):
        super().__init__()
        layout = QVBoxLayout(self)

        self.label = QLabel("ÈÄâÊã©Êñá‰ª∂Â§πÂêéÔºåËá™Âä®ÂàóÂá∫ÊâÄÊúâÂêàÊ≥ïÁöÑ model.jsonÔºõÈÄêË°åÈÄâÊã©Âπ∂Â•óÁî®È¢ÑËÆæ")
        layout.addWidget(self.label)

        top_btn_layout = QHBoxLayout()
        self.select_btn = QPushButton("üìÅ ÈÄâÊã©Êñá‰ª∂Â§π")
        self.select_btn.clicked.connect(self.select_folder)
        top_btn_layout.addWidget(self.select_btn)

        # Êù•Ê∫êÂ≠êÁõÆÂΩïÁõ∏ÂÖ≥
        self.source_subdir_combo = QComboBox()
        self.source_subdir_combo.setEnabled(False)
        self.source_subdir_combo.setPlaceholderText("ÂÖàÈÄâÊã©Ê†πÁõÆÂΩï‚Ä¶")
        top_btn_layout.addWidget(self.source_subdir_combo)

        self.all_subdirs_checkbox = QCheckBox("ÈÅçÂéÜÂÖ®ÈÉ®Â≠êÁõÆÂΩï")
        self.all_subdirs_checkbox.setChecked(False)
        self.all_subdirs_checkbox.toggled.connect(
            lambda checked: self.source_subdir_combo.setEnabled(not checked)
        )
        top_btn_layout.addWidget(self.all_subdirs_checkbox)

        # Â§çÂà∂/ÁßªÂä®ÈÄâÊã©
        self.copy_mode_checkbox = QCheckBox("‰ªÖÂ§çÂà∂ .mtn/.exp.jsonÔºà‰∏çÂà†Èô§Ê∫êÊñá‰ª∂Ôºâ")
        self.copy_mode_checkbox.setChecked(True)
        top_btn_layout.addWidget(self.copy_mode_checkbox)

        # ÊâπÈáèËÆæ‰∏∫Ôºà‰ΩúÁî®‰∫é‚ÄúÂãæÈÄâÁöÑË°å‚ÄùÔºâ
        self.bulk_preset_combo = QComboBox()
        self.bulk_apply_btn = QPushButton("ÊâπÈáèËÆæ‰∏∫")
        self.bulk_apply_btn.clicked.connect(self.apply_bulk_preset_to_checked_rows)
        top_btn_layout.addWidget(self.bulk_preset_combo)
        top_btn_layout.addWidget(self.bulk_apply_btn)

        # Â∫îÁî®ÊåâÈíÆ
        self.apply_btn = QPushButton("Â∫îÁî®ÊâÄÈÄâÈ¢ÑËÆæ")
        self.apply_btn.clicked.connect(self.apply_preset)
        top_btn_layout.addWidget(self.apply_btn)

        layout.addLayout(top_btn_layout)

        # È¢ÑËÆæËØ¥Êòé
        layout.addWidget(QLabel("ÊèêÁ§∫ÔºöÂú®‰∏ãË°®‰∏≠ÈÄêË°åÈÄâÊã©È¢ÑËÆæÔºõ‚Äú‰øùÊåÅ‰∏çÂèò‚ÄùÂ∞ÜË∑≥ËøáËØ•Ë°åÔºå‚ÄúÊ∏ÖÁ©∫(ÂÖ®0)‚Äù‰ºöÊääÊâÄÊúâÈÉ®‰ª∂ËÆæ‰∏∫0„ÄÇ"))

        # ‚úÖ Ë°®Ê†ºÔºöÊåâË°åÈÄâÊã©È¢ÑËÆæ
        self.json_table = QTableWidget()
        self.json_table.setColumnCount(5)
        self.json_table.setHorizontalHeaderLabels(["‚úî", "model.json Ë∑ØÂæÑ", "Ê£ÄÊµãÂà∞ÁöÑÈ¢ÑËÆæ", "ÈÄâÊã©È¢ÑËÆæ", "È¢ÑËßà"])
        self.json_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.Stretch)
        self.json_table.setColumnWidth(0, 44)
        self.json_table.setColumnWidth(2, 120)
        self.json_table.setColumnWidth(3, 160)
        self.json_table.setColumnWidth(4, 68)
        layout.addWidget(self.json_table)

        # === Êñ∞Â¢ûÔºö‰ªéÂçï‰∏ÄÊ∫ê JSON Â§çÂà∂ motions/expressions Âà∞ÂãæÈÄâÁõÆÊ†á ===
        copy_group = QGroupBox("üß© ‰ªéÂçï‰∏ÄÊ∫ê JSON Â§çÂà∂ motions / expressions Âà∞ÂãæÈÄâÁõÆÊ†á")
        copy_form = QFormLayout(copy_group)

        self.src_json_edit = QLineEdit()
        self.src_json_btn = QPushButton("ÈÄâÊã©Ê∫ê JSON‚Ä¶")
        self.src_json_btn.clicked.connect(self._browse_src_json)
        row_src = QHBoxLayout()
        row_src.addWidget(self.src_json_edit)
        row_src.addWidget(self.src_json_btn)
        copy_form.addRow("Ê∫ê JSONÔºö", row_src)

        opts_row = QHBoxLayout()
        self.rb_merge = QRadioButton("ÂêàÂπ∂ÔºàÂéªÈáçÔºâ")
        self.rb_overwrite = QRadioButton("Ë¶ÜÁõñ")
        self.rb_merge.setChecked(True)

        self.cb_motions = QCheckBox("motions")
        self.cb_expressions = QCheckBox("expressions")
        self.cb_motions.setChecked(True)
        self.cb_expressions.setChecked(True)

        opts_row.addWidget(self.rb_merge)
        opts_row.addWidget(self.rb_overwrite)
        opts_row.addSpacing(16)
        opts_row.addWidget(self.cb_motions)
        opts_row.addWidget(self.cb_expressions)
        copy_form.addRow("ÈÄâÈ°πÔºö", opts_row)

        self.copy_btn = QPushButton("Â§çÂà∂Âà∞ÂãæÈÄâÁöÑÁõÆÊ†á")
        self.copy_btn.clicked.connect(self.copy_src_fields_to_checked_rows)
        copy_form.addRow(self.copy_btn)

        layout.addWidget(copy_group)

        self.parts_data = {}
        self.root_dir = ""
        self.preset_names = []  # parts.json ÁöÑ key ÂàóË°®ÔºàÂä†ËΩΩÂêéÂ°´ÂÖÖÔºâ
        self.load_parts_json()

    def load_parts_json(self):
        if not os.path.exists(PARTS_JSON_PATH):
            QMessageBox.warning(self, "Ë≠¶Âëä", f"Êú™ÊâæÂà∞ parts.jsonÔºö{PARTS_JSON_PATH}")
            return
        with open(PARTS_JSON_PATH, encoding="utf-8") as f:
            self.parts_data = json.load(f)

        # È¢ÑËÆæ‰∏ãÊãâÁöÑÂèØÈÄâÈ°πÔºàÈ°∫Â∫èÂèØÊåâÈúÄË∞ÉÊï¥Ôºâ
        self.preset_names = list(self.parts_data.keys())
        specials = ["‰øùÊåÅ‰∏çÂèò", "Ê∏ÖÁ©∫(ÂÖ®0)"]
        # ÊâπÈáè‰∏ãÊãâ
        self.bulk_preset_combo.clear()
        self.bulk_preset_combo.addItems(specials + self.preset_names)

    def _list_first_level_subdirs(self, base):
        try:
            return sorted(
                [d for d in os.listdir(base) if os.path.isdir(os.path.join(base, d))]
            )
        except Exception:
            return []

    def select_folder(self):
        folder = QFileDialog.getExistingDirectory(self, "ÈÄâÊã©Ê®°ÂûãÊñá‰ª∂Â§π")
        if not folder:
            return

        self.root_dir = folder
        self.label.setText(f"‚úÖ Â∑≤ÈÄâÊã©Ôºö{folder}")
        self.json_table.setRowCount(0)

        # Â°´ÂÖÖÊù•Ê∫êÂ≠êÁõÆÂΩï
        subdirs = self._list_first_level_subdirs(folder)
        self.source_subdir_combo.clear()
        self.source_subdir_combo.setEnabled(False)
        if subdirs:
            self.source_subdir_combo.addItems(subdirs)
            self.source_subdir_combo.setEnabled(not self.all_subdirs_checkbox.isChecked())

        # Êûö‰∏æ model.json
        json_files = []
        def _collect_jsons(path, depth=0):
            if depth > 2:
                return
            try:
                for name in sorted(os.listdir(path)):
                    full = os.path.join(path, name)
                    if os.path.isdir(full):
                        _collect_jsons(full, depth + 1)
                    elif name.endswith(".json") and is_valid_live2d_json(full):
                        json_files.append(full)
            except Exception as e:
                print(f"‚ùå ÈîôËØØ: {e}")
        _collect_jsons(folder)

        # Â°´ÂÖÖË°®Ê†ºÔºàÈÄêË°åÂèØÈÄâÈ¢ÑËÆæÔºâ
        for i, abs_path in enumerate(json_files):
            self.json_table.insertRow(i)

            # ‚úî ÊòØÂê¶Â§ÑÁêÜ
            checkbox = QCheckBox()
            checkbox.setChecked(True)
            self.json_table.setCellWidget(i, 0, checkbox)

            # Ë∑ØÂæÑÂàóÔºöÊòæÁ§∫Áõ∏ÂØπË∑ØÂæÑÔºå‰ΩÜÊääÁªùÂØπË∑ØÂæÑÊîæÂà∞ UserRole
            disp = _display_relpath(abs_path, self.root_dir)
            path_item = QTableWidgetItem(disp)
            path_item.setData(Qt.UserRole, abs_path)  # ‚Üê Â≠òÁªùÂØπË∑ØÂæÑÔºåÂêéÈù¢ËØªËøô‰∏™
            path_item.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
            self.json_table.setItem(i, 1, path_item)

            # Ê£ÄÊµãÂà∞ÁöÑÈ¢ÑËÆæÔºàÁî®ÁªùÂØπË∑ØÂæÑËøõË°åÊ£ÄÊµãÔºâ
            detected = self.detect_preset(abs_path) or "Êó†"
            detected_item = QTableWidgetItem(detected)
            detected_item.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
            self.json_table.setItem(i, 2, detected_item)

            # ÈÄâÊã©È¢ÑËÆæ
            preset_combo = QComboBox()
            options = ["‰øùÊåÅ‰∏çÂèò", "Ê∏ÖÁ©∫(ÂÖ®0)"] + self.preset_names
            preset_combo.addItems(options)
            preset_combo.setCurrentText(detected if detected in self.preset_names else "‰øùÊåÅ‰∏çÂèò")
            self.json_table.setCellWidget(i, 3, preset_combo)

            # È¢ÑËßàÊåâÈíÆ
            preview_btn = QPushButton("Êü•Áúã")
            preview_btn.clicked.connect(lambda _, row=i: self.preview_row_preset(row))
            self.json_table.setCellWidget(i, 4, preview_btn)

    def preview_row_preset(self, row: int):
        """ÂºπÁ™óÂ±ïÁ§∫ËØ•Ë°å Combo ÈÄâ‰∏≠È¢ÑËÆæÂåÖÂê´ÁöÑÈÉ®‰ª∂Êï∞Èáè/ÂàóË°®"""
        combo = self.json_table.cellWidget(row, 3)
        if not combo:
            return
        name = combo.currentText()
        if name == "‰øùÊåÅ‰∏çÂèò":
            QMessageBox.information(self, "È¢ÑËßà", "‰øùÊåÅ‰∏çÂèòÔºà‰∏ç‰øÆÊîπËØ• model.json ÁöÑ init_opacitiesÔºâ")
            return
        if name == "Ê∏ÖÁ©∫(ÂÖ®0)":
            QMessageBox.information(self, "È¢ÑËßà", "Ê∏ÖÁ©∫ÔºöÊâÄÊúâÈÉ®‰ª∂ÈÄèÊòéÂ∫¶ÁΩÆ 0")
            return
        parts = self.parts_data.get(name, [])
        QMessageBox.information(
            self, "È¢ÑËßà",
            f"È¢ÑËÆæÔºö{name}\nÂåÖÂê´ {len(parts)} ‰∏™ÈÉ®‰ª∂IDÔºö\n" + (", ".join(parts[:100]) + (" ..." if len(parts) > 100 else ""))
        )

    def detect_preset(self, json_path):
        try:
            with open(json_path, encoding="utf-8") as f:
                model = json.load(f)
            if "init_opacities" not in model:
                return "Êó†"
            used_parts = [entry["id"] for entry in model["init_opacities"] if entry["value"] == 1.0]
            for category, parts in self.parts_data.items():
                if set(used_parts) == set(parts):
                    return category
            return "Ëá™ÂÆö‰πâ"
        except Exception:
            return "Êú™Áü•"

    # ÊâπÈáèÊää bulk_preset_combo ÈÄâ‰∏≠ÁöÑÈ¢ÑËÆæÔºåÂ∫îÁî®Âà∞‚ÄúÂãæÈÄâÁöÑË°å‚ÄùÁöÑ‚ÄúÈÄâÊã©È¢ÑËÆæ‚Äù‰∏ãÊãâÊ°Ü
    def apply_bulk_preset_to_checked_rows(self):
        preset_name = self.bulk_preset_combo.currentText().strip()
        for row in range(self.json_table.rowCount()):
            cb = self.json_table.cellWidget(row, 0)
            if cb and cb.isChecked():
                combo = self.json_table.cellWidget(row, 3)
                if combo:
                    combo.setCurrentText(preset_name)
        QMessageBox.information(self, "ÂÆåÊàê", f"Â∑≤Â∞Ü {preset_name} Â∫îÁî®‰∫éÂãæÈÄâË°åÁöÑ‚ÄúÈÄâÊã©È¢ÑËÆæ‚Äù‰∏ãÊãâ„ÄÇ")

    def apply_preset(self):
        # ÈÄêË°åÂ§ÑÁêÜ
        traverse_all = self.all_subdirs_checkbox.isChecked()
        if not traverse_all:
            if self.source_subdir_combo.count() == 0:
                QMessageBox.warning(self, "Ë≠¶Âëä", "Êú™ÊâæÂà∞ÂèØÁî®ÁöÑÊù•Ê∫êÂ≠êÁõÆÂΩïÔºåËØ∑ÂãæÈÄâ‚ÄúÈÅçÂéÜÂÖ®ÈÉ®Â≠êÁõÆÂΩï‚ÄùÊàñÈÄâÊã©ÊúâÂ≠êÁõÆÂΩïÁöÑÊ†πÁõÆÂΩï")
                return
            chosen_subdir = self.source_subdir_combo.currentText().strip()
            if not chosen_subdir:
                QMessageBox.warning(self, "Ë≠¶Âëä", "ËØ∑ÂÖàÈÄâÊã©Êù•Ê∫êÂ≠êÁõÆÂΩï")
                return

        use_copy_only = self.copy_mode_checkbox.isChecked()

        updated = 0
        exported = 0
        skipped = 0

        # ‚Äî‚Äî ÂÜôÂÖ•ÂêÑËá™È¢ÑËÆæ
        for row in range(self.json_table.rowCount()):
            cb = self.json_table.cellWidget(row, 0)
            if not (cb and cb.isChecked()):
                continue

            path_item = self.json_table.item(row, 1)
            combo = self.json_table.cellWidget(row, 3)
            if not path_item or not combo:
                continue

            json_path = path_item.data(Qt.UserRole)  # ÁªùÂØπË∑ØÂæÑ
            choice = combo.currentText().strip()

            if choice == "‰øùÊåÅ‰∏çÂèò":
                continue

            try:
                all_parts = get_all_parts(json_path)
                if choice == "Ê∏ÖÁ©∫(ÂÖ®0)":
                    target_parts = set()
                else:
                    target_parts = set(self.parts_data.get(choice, []))

                init_opacities = [
                    {"id": pid, "value": 1.0 if pid in target_parts else 0.0}
                    for pid in all_parts
                ]

                with open(json_path, "r", encoding="utf-8") as f:
                    model_data = json.load(f)
                model_data.pop("motions", None)
                model_data.pop("expressions", None)
                model_data["init_opacities"] = init_opacities
                with open(json_path, "w", encoding="utf-8") as f:
                    json.dump(model_data, f, ensure_ascii=False, indent=2)
                updated += 1
            except Exception as e:
                print(f"‚ùå Â§ÑÁêÜÂ§±Ë¥•: {json_path} ÈîôËØØ: {e}")

        # ‚Äî‚Äî ÈõÜ‰∏≠Âä®‰Ωú/Ë°®ÊÉÖ
        try:
            if traverse_all:
                for dirpath, _, filenames in os.walk(self.root_dir):
                    for file in filenames:
                        low = file.lower()
                        if not (low.endswith(".mtn") or low.endswith(".exp.json")):
                            continue
                        src = os.path.join(dirpath, file)
                        rel = os.path.relpath(dirpath, self.root_dir)
                        top = rel.split(os.sep)[0] if rel != "." else "_root"
                        export_dir = os.path.join(self.root_dir, "expnmtn", top)
                        _ensure_dir(export_dir)
                        try:
                            if use_copy_only:
                                final_dst = _dedup_target_path(os.path.join(export_dir, file))
                                shutil.copy2(src, final_dst)
                                _fsync_file(final_dst); _fsync_dir(export_dir)
                            else:
                                _ = safe_move(src, os.path.join(export_dir, file))
                            exported += 1
                        except Exception as e:
                            print(f"‚ùå ÈõÜ‰∏≠Â§±Ë¥•Ôºö{src} -> {export_dir}ÔºåÈîôËØØ: {e}")
                            skipped += 1
            else:
                source_base = os.path.join(self.root_dir, chosen_subdir)
                if not os.path.isdir(source_base):
                    print(f"‚ö†Ô∏è Êù•Ê∫êÂ≠êÁõÆÂΩï‰∏çÂ≠òÂú®Ôºö{os.path.normpath(source_base)}")
                else:
                    export_dir = os.path.join(self.root_dir, "expnmtn", chosen_subdir)
                    _ensure_dir(export_dir)
                    for dirpath, _, filenames in os.walk(source_base):
                        for file in filenames:
                            low = file.lower()
                            if not (low.endswith(".mtn") or low.endswith(".exp.json")):
                                continue
                            src = os.path.join(dirpath, file)
                            try:
                                if use_copy_only:
                                    final_dst = _dedup_target_path(os.path.join(export_dir, file))
                                    shutil.copy2(src, final_dst)
                                    _fsync_file(final_dst); _fsync_dir(export_dir)
                                else:
                                    _ = safe_move(src, os.path.join(export_dir, file))
                                exported += 1
                            except Exception as e:
                                print(f"‚ùå ÈõÜ‰∏≠Â§±Ë¥•Ôºö{src} -> {export_dir}ÔºåÈîôËØØ: {e}")
                                skipped += 1
        except Exception as e:
            print(f"‚ùå ÈÅçÂéÜÈîôËØØÔºö{e}")

        QMessageBox.information(
            self,
            "ÂÆåÊàê",
            f"Â∑≤Êõ¥Êñ∞ init_opacitiesÔºö{updated} ‰∏™\n"
            f"{'Â§çÂà∂' if use_copy_only else 'ÁßªÂä®'}‰∫Ü {exported} ‰∏™Âä®‰Ωú/Ë°®ÊÉÖÂà∞ expnmtn\\(ÊåâÈ¶ñÂ±ÇÁõÆÂΩïÂàÜÁªÑ)\n"
            f"Ë∑≥Ëøá/Â§±Ë¥•Ôºö{skipped}"
        )

    # ========= Êñ∞Â¢ûÔºö‰ªéÂçï‰∏ÄÊ∫ê JSON Â§çÂà∂Âà∞ÂãæÈÄâÁõÆÊ†á =========
    def _browse_src_json(self):
        path, _ = QFileDialog.getOpenFileName(self, "ÈÄâÊã©Ê∫ê model.json", filter="JSON (*.json)")
        if path:
            self.src_json_edit.setText(path)

    def copy_src_fields_to_checked_rows(self):
        src_path = self.src_json_edit.text().strip()
        if not (src_path and os.path.isfile(src_path)):
            QMessageBox.warning(self, "‚ö†Ô∏è", "ËØ∑ÂÖàÈÄâÊã©Ê≠£Á°ÆÁöÑÊ∫ê model.json")
            return
        if not (self.cb_motions.isChecked() or self.cb_expressions.isChecked()):
            QMessageBox.warning(self, "‚ö†Ô∏è", "ËØ∑Ëá≥Â∞ëÂãæÈÄâ motions Êàñ expressions ‰πã‰∏Ä")
            return

        # ËØªÂèñÊ∫ê
        try:
            with open(src_path, "r", encoding="utf-8") as f:
                src_obj = json.load(f)
        except Exception as e:
            QMessageBox.critical(self, "‚ùå Âá∫Èîô", f"ËØªÂèñÊ∫ê JSON Â§±Ë¥•Ôºö\n{e}")
            return

        mode = "merge" if self.rb_merge.isChecked() else "overwrite"
        success, fail = 0, 0

        # ÂØπÂãæÈÄâË°åÊâßË°åÂ§çÂà∂
        for row in range(self.json_table.rowCount()):
            cb = self.json_table.cellWidget(row, 0)
            if not (cb and cb.isChecked()):
                continue
            path_item = self.json_table.item(row, 1)
            if not path_item:
                continue
            dst_path = path_item.data(Qt.UserRole)
            if not (dst_path and os.path.isfile(dst_path)):
                continue

            try:
                with open(dst_path, "r", encoding="utf-8") as f:
                    dst_obj = json.load(f)

                if self.cb_motions.isChecked():
                    dst_obj = self._apply_copy_for_field("motions", src_obj, dst_obj, mode)
                if self.cb_expressions.isChecked():
                    dst_obj = self._apply_copy_for_field("expressions", src_obj, dst_obj, mode)

                self._safe_backup(dst_path)
                with open(dst_path, "w", encoding="utf-8") as f:
                    json.dump(dst_obj, f, ensure_ascii=False, indent=2)
                success += 1
            except Exception as e:
                print(f"[Â§çÂà∂Â§±Ë¥•] {dst_path}: {e}")
                fail += 1

        QMessageBox.information(self, "ÂÆåÊàê", f"Â§çÂà∂ÂÆåÊàêÔºöÊàêÂäü {success} ‰∏™ÔºåÂ§±Ë¥• {fail} ‰∏™„ÄÇ")

    def _apply_copy_for_field(self, field: str, src_obj: dict, target: dict, mode: str):
        s_val = src_obj.get(field)
        t_val = target.get(field)

        if mode == "overwrite":
            merged = self._merge_field_values(s_val, None, None)
            if merged is not None:
                target[field] = merged
            else:
                target.pop(field, None)
        else:
            merged = self._merge_field_values(s_val, None, t_val)
            if merged is not None:
                target[field] = merged
            else:
                target.pop(field, None)
        return target

    def _merge_field_values(self, a_val, b_val, t_val):
        """
        ÂêàÂπ∂‰∏§Â§ßÁ±ªÁªìÊûÑÂπ∂ÂéªÈáçÔºö
        1) dict: { "name": [ {"file": "..."} ] }
        2) list: [ {"name":"...", "file":"..."} ]
        a_val: Ê∫êÔºõb_val: ÂÖºÂÆπÂç†‰ΩçÔºåËøôÈáåÂõ∫ÂÆö NoneÔºõt_val: ÁõÆÊ†áÂéüÂÄº
        """
        if a_val is None and t_val is None:
            return None

        has_dict = any(isinstance(v, dict) for v in (a_val, t_val) if v is not None)

        if has_dict:
            # ÁõÆÊ†áÁªìÊûÑÔºödict[str, list[{"file": "..."}]]
            base = {}
            for src in (t_val, a_val):  # ÂÖà‰øùÁïô targetÔºåÂÜçÂè†Âä†Ê∫ê
                if not isinstance(src, dict):
                    continue
                for k, arr in src.items():
                    if not isinstance(arr, list):
                        continue
                    bucket = base.setdefault(k, [])
                    seen = {json.dumps(x, sort_keys=True) for x in bucket if isinstance(x, dict)}
                    for x in arr:
                        if not isinstance(x, dict):
                            continue
                        key = json.dumps(x, sort_keys=True)
                        if key not in seen:
                            bucket.append(x)
                            seen.add(key)
            return base if base else None
        else:
            # ÁõÆÊ†áÁªìÊûÑÔºölist[{"name": "...", "file": "..."}]
            merged_list = []
            seen_pairs = set()

            def add_from(src):
                if not isinstance(src, list):
                    return
                for x in src:
                    if not isinstance(x, dict):
                        continue
                    name = x.get("name")
                    file_ = x.get("file")
                    key = (name, file_)
                    if key not in seen_pairs:
                        merged_list.append(x)
                        seen_pairs.add(key)

            for src in (t_val, a_val):
                add_from(src)

            return merged_list if merged_list else None

    def _safe_backup(self, path: str):
        try:
            bak = path + ".bak"
            if not os.path.exists(bak):
                import shutil
                shutil.copy2(path, bak)
        except Exception:
            pass
